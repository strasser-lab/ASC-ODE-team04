{"version":"1","records":[{"hierarchy":{"lvl1":"The Autodiff Class"},"type":"lvl1","url":"/autodiff","position":0},{"hierarchy":{"lvl1":"The Autodiff Class"},"content":"","type":"content","url":"/autodiff","position":1},{"hierarchy":{"lvl1":"The Autodiff Class","lvl3":"Exercise 18.4"},"type":"lvl3","url":"/autodiff#exercise-18-4","position":2},{"hierarchy":{"lvl1":"The Autodiff Class","lvl3":"Exercise 18.4"},"content":"In this exercise we had to:\n\nAdd additional useful operators for the AutoDiff class\n\nAdd some more functions (cos, exp, log, ‚Ä¶) for the AutoDiff class.\n\nEvaluate and plot Legendre-polynomials up to order 5, in the interval -1 \\le x \\le 1. Evaluate and plot also their derivatives (using AutoDiff).","type":"content","url":"/autodiff#exercise-18-4","position":3},{"hierarchy":{"lvl1":"The Autodiff Class","lvl3":"Implemented operators/functions (subtask 1, 2)"},"type":"lvl3","url":"/autodiff#implemented-operators-functions-subtask-1-2","position":4},{"hierarchy":{"lvl1":"The Autodiff Class","lvl3":"Implemented operators/functions (subtask 1, 2)"},"content":"We implemented some useful operators and functions for the AutoDiff class in the autodiff.hpp.","type":"content","url":"/autodiff#implemented-operators-functions-subtask-1-2","position":5},{"hierarchy":{"lvl1":"The Autodiff Class","lvl4":"Arithmetic operators","lvl3":"Implemented operators/functions (subtask 1, 2)"},"type":"lvl4","url":"/autodiff#arithmetic-operators","position":6},{"hierarchy":{"lvl1":"The Autodiff Class","lvl4":"Arithmetic operators","lvl3":"Implemented operators/functions (subtask 1, 2)"},"content":"We have:\n\\\\ u(x) and its derivative u' \\\\\nv(x) and its derivative v' \\\\\n\nThen,","type":"content","url":"/autodiff#arithmetic-operators","position":7},{"hierarchy":{"lvl1":"The Autodiff Class","lvl5":"Addition","lvl4":"Arithmetic operators","lvl3":"Implemented operators/functions (subtask 1, 2)"},"type":"lvl5","url":"/autodiff#addition","position":8},{"hierarchy":{"lvl1":"The Autodiff Class","lvl5":"Addition","lvl4":"Arithmetic operators","lvl3":"Implemented operators/functions (subtask 1, 2)"},"content":"Mathematics:f(x) = u(x) + v(x), \\quad f'(x) = u' + v'\n\nExample:f(x) = x^2 + 3x \\Rightarrow f'(x) = 2x + 3\n\nIn the code the implementation is:template <typename T>\nAutoDiff<T> operator+(const AutoDiff<T>& a, const AutoDiff<T>& b) {\n    return AutoDiff<T>(a.val + b.val, a.der + b.der);\n}","type":"content","url":"/autodiff#addition","position":9},{"hierarchy":{"lvl1":"The Autodiff Class","lvl5":"Subtraction","lvl4":"Arithmetic operators","lvl3":"Implemented operators/functions (subtask 1, 2)"},"type":"lvl5","url":"/autodiff#subtraction","position":10},{"hierarchy":{"lvl1":"The Autodiff Class","lvl5":"Subtraction","lvl4":"Arithmetic operators","lvl3":"Implemented operators/functions (subtask 1, 2)"},"content":"Mathematics:f(x) = u(x) - v(x), \\quad f'(x) = u' - v'\n\nExample:f(x) = x^2 - \\sin(x) \\Rightarrow f'(x) = 2x - \\cos(x)\n\nIn the code the implementation is:template <typename T>\nAutoDiff<T> operator-(const AutoDiff<T>& a, const AutoDiff<T>& b) {\n    return AutoDiff<T>(a.val - b.val, a.der - b.der);\n}","type":"content","url":"/autodiff#subtraction","position":11},{"hierarchy":{"lvl1":"The Autodiff Class","lvl5":"Multiplication","lvl4":"Arithmetic operators","lvl3":"Implemented operators/functions (subtask 1, 2)"},"type":"lvl5","url":"/autodiff#multiplication","position":12},{"hierarchy":{"lvl1":"The Autodiff Class","lvl5":"Multiplication","lvl4":"Arithmetic operators","lvl3":"Implemented operators/functions (subtask 1, 2)"},"content":"Mathematics:f(x) = u(x) \\cdot v(x), \\quad f'(x) = u'v + uv'\n\nExample:f(x) = x \\cdot \\sin(x) \\Rightarrow f'(x) = \\sin(x) + x\\cos(x)\n\nIn the code the implementation is:template <typename T>\nAutoDiff<T> operator*(const AutoDiff<T>& a, const AutoDiff<T>& b) {\n    return AutoDiff<T>(a.val * b.val, a.der * b.val + a.val * b.der);\n}","type":"content","url":"/autodiff#multiplication","position":13},{"hierarchy":{"lvl1":"The Autodiff Class","lvl5":"Division","lvl4":"Arithmetic operators","lvl3":"Implemented operators/functions (subtask 1, 2)"},"type":"lvl5","url":"/autodiff#division","position":14},{"hierarchy":{"lvl1":"The Autodiff Class","lvl5":"Division","lvl4":"Arithmetic operators","lvl3":"Implemented operators/functions (subtask 1, 2)"},"content":"Mathematics:f(x) = \\frac{u(x)}{v(x)}, \\quad f'(x) = \\frac{u'v - uv'}{v^2}\n\nExample:f(x) = \\frac{x}{x + 1} \\Rightarrow f'(x) = \\frac{1}{(x + 1)^2}\n\nIn the code the implementation is:AutoDiff<T> operator/(const AutoDiff<T>& a, const AutoDiff<T>& b) {\n    T bv = b.val;\n    return AutoDiff<T>(a.val / bv,\n                       (a.der * bv - a.val * b.der) / (bv * bv));\n}","type":"content","url":"/autodiff#division","position":15},{"hierarchy":{"lvl1":"The Autodiff Class","lvl5":"Negative sign","lvl4":"Arithmetic operators","lvl3":"Implemented operators/functions (subtask 1, 2)"},"type":"lvl5","url":"/autodiff#negative-sign","position":16},{"hierarchy":{"lvl1":"The Autodiff Class","lvl5":"Negative sign","lvl4":"Arithmetic operators","lvl3":"Implemented operators/functions (subtask 1, 2)"},"content":"Mathematics:f(x) = -u(x), \\quad f'(x) = -u'\n\nExample:f(x) = \\cos(x) \\Rightarrow f'(x) = \\sin(x)\n\nIn the code the implementation is:template <typename T>\nAutoDiff<T> operator-(const AutoDiff<T>& a) {\n    return AutoDiff<T>(-a.val, -a.der);\n}","type":"content","url":"/autodiff#negative-sign","position":17},{"hierarchy":{"lvl1":"The Autodiff Class","lvl4":"Elementary functions","lvl3":"Implemented operators/functions (subtask 1, 2)"},"type":"lvl4","url":"/autodiff#elementary-functions","position":18},{"hierarchy":{"lvl1":"The Autodiff Class","lvl4":"Elementary functions","lvl3":"Implemented operators/functions (subtask 1, 2)"},"content":"Here we implemented the following useful elementary functions.\nWe have:\n\\\\ u(x) and its derivative u' \\\\\n\nThen,","type":"content","url":"/autodiff#elementary-functions","position":19},{"hierarchy":{"lvl1":"The Autodiff Class","lvl5":"Sinus","lvl4":"Elementary functions","lvl3":"Implemented operators/functions (subtask 1, 2)"},"type":"lvl5","url":"/autodiff#sinus","position":20},{"hierarchy":{"lvl1":"The Autodiff Class","lvl5":"Sinus","lvl4":"Elementary functions","lvl3":"Implemented operators/functions (subtask 1, 2)"},"content":"Mathematics:f(x) = \\sin(u(x)) \\Rightarrow f'(x) = \\cos(u(x)) \\cdot u'(x)\n\nExample:f(x) = \\sin(x) \\Rightarrow f'(x) = \\cos(x)\n\nIn the code the implementation is:template <typename T>\nAutoDiff<T> sin(const AutoDiff<T>& a) {\n    return AutoDiff<T>(std::sin(a.val), std::cos(a.val) * a.der);\n}","type":"content","url":"/autodiff#sinus","position":21},{"hierarchy":{"lvl1":"The Autodiff Class","lvl5":"Cosinus","lvl4":"Elementary functions","lvl3":"Implemented operators/functions (subtask 1, 2)"},"type":"lvl5","url":"/autodiff#cosinus","position":22},{"hierarchy":{"lvl1":"The Autodiff Class","lvl5":"Cosinus","lvl4":"Elementary functions","lvl3":"Implemented operators/functions (subtask 1, 2)"},"content":"Mathematics:f(x) = \\cos(u(x)) \\Rightarrow f'(x) = -\\sin(u(x)) \\cdot u'(x)\n\nExample:f(x) = \\cos(x) \\Rightarrow f'(x) = -\\sin(x)\n\nIn the code the implementation is:template <typename T>\nAutoDiff<T> cos(const AutoDiff<T>& a) {\n    return AutoDiff<T>(std::cos(a.val), -std::sin(a.val) * a.der);\n}","type":"content","url":"/autodiff#cosinus","position":23},{"hierarchy":{"lvl1":"The Autodiff Class","lvl5":"Exponential","lvl4":"Elementary functions","lvl3":"Implemented operators/functions (subtask 1, 2)"},"type":"lvl5","url":"/autodiff#exponential","position":24},{"hierarchy":{"lvl1":"The Autodiff Class","lvl5":"Exponential","lvl4":"Elementary functions","lvl3":"Implemented operators/functions (subtask 1, 2)"},"content":"Mathematics:f(x) = e^{u(x)} \\Rightarrow f'(x) = e^{u(x)} \\cdot u'(x)\n\nExample:f(x) = e^x \\Rightarrow f'(x) = e^x\n\nIn the code the implementation is:template <typename T>\nAutoDiff<T> exp(const AutoDiff<T>& a) {\n    T ev = std::exp(a.val);\n    return AutoDiff<T>(ev, ev * a.der);\n}","type":"content","url":"/autodiff#exponential","position":25},{"hierarchy":{"lvl1":"The Autodiff Class","lvl5":"Logarithm","lvl4":"Elementary functions","lvl3":"Implemented operators/functions (subtask 1, 2)"},"type":"lvl5","url":"/autodiff#logarithm","position":26},{"hierarchy":{"lvl1":"The Autodiff Class","lvl5":"Logarithm","lvl4":"Elementary functions","lvl3":"Implemented operators/functions (subtask 1, 2)"},"content":"Mathematics:f(x) = \\ln(u(x)) \\Rightarrow f'(x) = \\frac{u'(x)}{u(x)}\n\nExample:f(x) = \\ln(e^x) = x \\Rightarrow f'(x) = \\frac{1}{e^x} \\cdot e^x = 1\n\nIn the code the implementation is:template <typename T>\nAutoDiff<T> log(const AutoDiff<T>& a) {\n    return AutoDiff<T>(std::log(a.val), a.der / a.val);\n}","type":"content","url":"/autodiff#logarithm","position":27},{"hierarchy":{"lvl1":"The Autodiff Class","lvl5":"Power","lvl4":"Elementary functions","lvl3":"Implemented operators/functions (subtask 1, 2)"},"type":"lvl5","url":"/autodiff#power","position":28},{"hierarchy":{"lvl1":"The Autodiff Class","lvl5":"Power","lvl4":"Elementary functions","lvl3":"Implemented operators/functions (subtask 1, 2)"},"content":"Mathematics:f(x) = (u(x))^c \\Rightarrow f'(x) = c \\cdot (u(x))^{c-1} \\cdot u'(x)\n\nExample:f(x) = x^3 \\Rightarrow f'(x) = 3x^2\n\nIn the code the implementation is:template <typename T>\nAutoDiff<T> pow(const AutoDiff<T>& a, T exponent) {\n    T v = std::pow(a.val, exponent);\n    T factor = exponent * std::pow(a.val, exponent - 1);\n    return AutoDiff<T>(v, factor * a.der);\n}","type":"content","url":"/autodiff#power","position":29},{"hierarchy":{"lvl1":"The Autodiff Class","lvl4":"Scalar operations","lvl3":"Implemented operators/functions (subtask 1, 2)"},"type":"lvl4","url":"/autodiff#scalar-operations","position":30},{"hierarchy":{"lvl1":"The Autodiff Class","lvl4":"Scalar operations","lvl3":"Implemented operators/functions (subtask 1, 2)"},"content":"Here we implemented the following scalar operations.\nWe have:\n\\\\ u(x) and its derivative u' \\\\\nc as a scalar\n\nThen,","type":"content","url":"/autodiff#scalar-operations","position":31},{"hierarchy":{"lvl1":"The Autodiff Class","lvl5":"Multiplication","lvl4":"Scalar operations","lvl3":"Implemented operators/functions (subtask 1, 2)"},"type":"lvl5","url":"/autodiff#multiplication-1","position":32},{"hierarchy":{"lvl1":"The Autodiff Class","lvl5":"Multiplication","lvl4":"Scalar operations","lvl3":"Implemented operators/functions (subtask 1, 2)"},"content":"Mathematics:f(x) = c \\cdot u(x) \\Rightarrow f'(x) = c \\cdot u'(x)f(x) = u(x) \\cdot c \\Rightarrow f'(x) = u'(x) \\cdot c\n\nExample:f(x) = 5x \\Rightarrow f'(x) = 5\n\nIn the code the implementation is:template <typename T, typename S>\nAutoDiff<T> operator*(S scalar, const AutoDiff<T>& a) {\n    return AutoDiff<T>(scalar * a.val, scalar * a.der);\n}\n\ntemplate <typename T, typename S>\nAutoDiff<T> operator*(const AutoDiff<T>& a, S scalar) {\n    return scalar * a;\n}","type":"content","url":"/autodiff#multiplication-1","position":33},{"hierarchy":{"lvl1":"The Autodiff Class","lvl5":"Addition","lvl4":"Scalar operations","lvl3":"Implemented operators/functions (subtask 1, 2)"},"type":"lvl5","url":"/autodiff#addition-1","position":34},{"hierarchy":{"lvl1":"The Autodiff Class","lvl5":"Addition","lvl4":"Scalar operations","lvl3":"Implemented operators/functions (subtask 1, 2)"},"content":"Mathematics:f(x) = c + u(x) \\Rightarrow f'(x) = u'(x)f(x) = u(x) + c \\Rightarrow f'(x) = u'(x)\n\nExample:f(x) = x + 10 \\Rightarrow f'(x) = 1\n\nIn the code the implementation is:template <typename T, typename S>\nAutoDiff<T> operator+(S scalar, const AutoDiff<T>& a) {\n    return AutoDiff<T>(scalar + a.val, a.der);\n}\n\ntemplate <typename T, typename S>\nAutoDiff<T> operator+(const AutoDiff<T>& a, S scalar) {\n    return a + scalar;\n}","type":"content","url":"/autodiff#addition-1","position":35},{"hierarchy":{"lvl1":"The Autodiff Class","lvl5":"Subtraction","lvl4":"Scalar operations","lvl3":"Implemented operators/functions (subtask 1, 2)"},"type":"lvl5","url":"/autodiff#subtraction-1","position":36},{"hierarchy":{"lvl1":"The Autodiff Class","lvl5":"Subtraction","lvl4":"Scalar operations","lvl3":"Implemented operators/functions (subtask 1, 2)"},"content":"Mathematics:f(x) = c - u(x) \\Rightarrow f'(x) = -u'(x)f(x) = u(x) - c \\Rightarrow f'(x) = u'(x)\n\nExample:f(x) = 7 - x \\Rightarrow f'(x) = -1\n\nIn the code the implementation is:template <typename T, typename S>\nAutoDiff<T> operator-(S scalar, const AutoDiff<T>& a) {\n    return AutoDiff<T>(scalar - a.val, -a.der);\n}\n\ntemplate <typename T, typename S>\nAutoDiff<T> operator-(const AutoDiff<T>& a, S scalar) {\n    return AutoDiff<T>(a.val - scalar, a.der);\n}","type":"content","url":"/autodiff#subtraction-1","position":37},{"hierarchy":{"lvl1":"The Autodiff Class","lvl5":"Division","lvl4":"Scalar operations","lvl3":"Implemented operators/functions (subtask 1, 2)"},"type":"lvl5","url":"/autodiff#division-1","position":38},{"hierarchy":{"lvl1":"The Autodiff Class","lvl5":"Division","lvl4":"Scalar operations","lvl3":"Implemented operators/functions (subtask 1, 2)"},"content":"Mathematics:f(x) = \\frac{u(x)}{c} \\Rightarrow f'(x) = \\frac{u'(x)}{c}f(x) = \\frac{c}{u(x)} \\Rightarrow f'(x) = \\frac{-c \\cdot u'(x)}{u(x)^2}\n\nExample:f(x) = \\frac{x}{2} \\Rightarrow f'(x) = \\frac{1}{2}f(x) = \\frac{8}{x} \\Rightarrow f'(x) = -\\frac{8}{x^2}\n\nIn the code the implementation is:template <typename T, typename S>\nAutoDiff<T> operator/(const AutoDiff<T>& a, S scalar)\n{\n    return AutoDiff<T>(a.val / scalar, a.der / scalar);\n}\n\ntemplate <typename T, typename S>\nAutoDiff<T> operator/(S scalar, const AutoDiff<T>& a)\n{\n    T g  = a.val;\n    T g2 = g * g;\n    return AutoDiff<T>(scalar / g, -scalar * a.der / g2);\n}","type":"content","url":"/autodiff#division-1","position":39},{"hierarchy":{"lvl1":"The Autodiff Class","lvl3":"Evaluate and plot Legendre-polynomials (and their derivatives) up to order 5, in the interval -1 \\le x \\le 1 (subtask 3)"},"type":"lvl3","url":"/autodiff#evaluate-and-plot-legendre-polynomials-and-their-derivatives-up-to-order-5-in-the-interval-1-le-x-le-1-subtask-3","position":40},{"hierarchy":{"lvl1":"The Autodiff Class","lvl3":"Evaluate and plot Legendre-polynomials (and their derivatives) up to order 5, in the interval -1 \\le x \\le 1 (subtask 3)"},"content":"We implemented this process in main.cpp. It evaluates in the interval -1 \\le x \\le 1 the Legendre-polynomials up to order 5 and their derivatives (using AutoDiff). For the plot, it generates a legendre.csv file that can be plotted using plot_legendre.py program.","type":"content","url":"/autodiff#evaluate-and-plot-legendre-polynomials-and-their-derivatives-up-to-order-5-in-the-interval-1-le-x-le-1-subtask-3","position":41},{"hierarchy":{"lvl1":"The Autodiff Class","lvl4":"Evaluation","lvl3":"Evaluate and plot Legendre-polynomials (and their derivatives) up to order 5, in the interval -1 \\le x \\le 1 (subtask 3)"},"type":"lvl4","url":"/autodiff#evaluation","position":42},{"hierarchy":{"lvl1":"The Autodiff Class","lvl4":"Evaluation","lvl3":"Evaluate and plot Legendre-polynomials (and their derivatives) up to order 5, in the interval -1 \\le x \\le 1 (subtask 3)"},"content":"The Legendre polynomials are defined using the following recursive form:\\begin{aligned}\nP_{0} = 1 \\\\\nP_{1} = x \\\\\nP_{k}(x) = \\frac{(2k - 1)xP_{k-1}(x) - (k - 1)P_{k-2}(x)}{k}, \\qquad k \\ge 2\n\\end{aligned}\n\nThe program evaluates P, \\, P' for 400 (x) points in the interval [-1,1]. So it computes the values of the Legendre polynomials, and the values of their derivatives for each point.\nThen the program writes the results into the legendre.csv file in the following format:x, \\quad P_0, \\quad P_{0}', \\quad P_1, \\quad P_{1}', \\quad P_2, \\quad P_{2}', \\quad P_3, \\quad P_{3}', \\quad P_4, \\quad P_{4}', \\quad P_5, \\quad P_{5}'\n\nFor example a line looks like this:0.5, \\quad 1.0, \\quad 0.0, \\quad 0.5, \\quad 1.0, \\quad -0.375, \\quad 3.0, \\quad 0.625, \\quad 7.5, \\quad -0.625, \\quad -15.0, \\quad -1.875, \\quad -18.75\n\n(So for instance: P'_{5}(0.5) = -18.75)\n\nIn the end it also prints in the command window, whether the legendre.csv was created succesfully.","type":"content","url":"/autodiff#evaluation","position":43},{"hierarchy":{"lvl1":"The Autodiff Class","lvl4":"Plots","lvl3":"Evaluate and plot Legendre-polynomials (and their derivatives) up to order 5, in the interval -1 \\le x \\le 1 (subtask 3)"},"type":"lvl4","url":"/autodiff#plots","position":44},{"hierarchy":{"lvl1":"The Autodiff Class","lvl4":"Plots","lvl3":"Evaluate and plot Legendre-polynomials (and their derivatives) up to order 5, in the interval -1 \\le x \\le 1 (subtask 3)"},"content":"After running the plotting plot_legendre.py program, we got the following plot:\n","type":"content","url":"/autodiff#plots","position":45},{"hierarchy":{"lvl1":"The Autodiff Class","lvl2":"Exercise 18.5 (Pendulum)"},"type":"lvl2","url":"/autodiff#exercise-18-5-pendulum","position":46},{"hierarchy":{"lvl1":"The Autodiff Class","lvl2":"Exercise 18.5 (Pendulum)"},"content":"In this section, we demonstrate how to implement differential equations without explicitly providing the derivatives (see, for example, Exercise 17.5.1).\nTo achieve this, we introduce the AutoDiff class, which handles the differentiation automatically.\n\nFor the pendulum, the governing second-order ODE is:\\alpha^{\\prime \\prime} = -\\frac{g}{l} \\sin (\\alpha), \\qquad \\alpha(t_0) = \\pi +0.001, \\; \\alpha^\\prime(t_0) = 0,\n\nOur results are consistent with previous conclusions\n\nExplicit Euler accumulates numerical errors and introduces artificial energy into the system.\nThis leads to an overestimation of the amplitude.\n\nCrank‚ÄìNicolson behaves as expected: the oscillations remain stable and physically correct, even with only a tiny perturbation in the initial angle.","type":"content","url":"/autodiff#exercise-18-5-pendulum","position":47},{"hierarchy":{"lvl1":"The Autodiff Class","lvl3":"State Space","lvl2":"Exercise 18.5 (Pendulum)"},"type":"lvl3","url":"/autodiff#state-space","position":48},{"hierarchy":{"lvl1":"The Autodiff Class","lvl3":"State Space","lvl2":"Exercise 18.5 (Pendulum)"},"content":"","type":"content","url":"/autodiff#state-space","position":49},{"hierarchy":{"lvl1":"The Autodiff Class","lvl3":"Pendulum solution","lvl2":"Exercise 18.5 (Pendulum)"},"type":"lvl3","url":"/autodiff#pendulum-solution","position":50},{"hierarchy":{"lvl1":"The Autodiff Class","lvl3":"Pendulum solution","lvl2":"Exercise 18.5 (Pendulum)"},"content":"\n","type":"content","url":"/autodiff#pendulum-solution","position":51},{"hierarchy":{"lvl1":"Crank‚ÄìNicolson Method"},"type":"lvl1","url":"/crank-nicolson","position":0},{"hierarchy":{"lvl1":"Crank‚ÄìNicolson Method"},"content":"","type":"content","url":"/crank-nicolson","position":1},{"hierarchy":{"lvl1":"Crank‚ÄìNicolson Method","lvl2":"Exercise 17.4.1"},"type":"lvl2","url":"/crank-nicolson#exercise-17-4-1","position":2},{"hierarchy":{"lvl1":"Crank‚ÄìNicolson Method","lvl2":"Exercise 17.4.1"},"content":"In this exercise we had to:\n\nimplement the Crank‚ÄìNicolson method\n\ncompare the three methods to each other\n\nuse the three methods to solve an electronic network","type":"content","url":"/crank-nicolson#exercise-17-4-1","position":3},{"hierarchy":{"lvl1":"Crank‚ÄìNicolson Method","lvl2":"Crank‚ÄìNicolson"},"type":"lvl2","url":"/crank-nicolson#crank-nicolson","position":4},{"hierarchy":{"lvl1":"Crank‚ÄìNicolson Method","lvl2":"Crank‚ÄìNicolson"},"content":"The Crank‚ÄìNicolson method has been implemented in\n\ntimestepper.hpp.\n\nThe method is defined as:y_{i+1} = y_i + \\frac{\\tau}{2}\\big(f(t_i, y_i) + f(t_{i+1}, y_{i+1})\\big)\n\nTo achieve this, we adapted the code for the implicit and explicit Euler methods and implemented the formula above.\n  class CrankNicolson : public TimeStepper\n  {\n    std::shared_ptr<NonlinearFunction> m_equ;\n    std::shared_ptr<Parameter> m_tau_half;\n    std::shared_ptr<ConstantFunction> m_yold;\n    Vector<> m_vecf;\n    std::shared_ptr<ConstantFunction> m_fold;\n  public:\n    CrankNicolson(std::shared_ptr<NonlinearFunction> rhs) \n    : TimeStepper(rhs), m_tau_half(std::make_shared<Parameter>(0.0)) \n      , m_vecf(rhs->dimF())\n    {\n      m_yold = std::make_shared<ConstantFunction>(rhs->dimX());\n      m_fold = std::make_shared<ConstantFunction>(rhs->dimF());\n      auto ynew = std::make_shared<IdentityFunction>(rhs->dimX());\n      m_equ = m_yold + m_tau_half * (m_fold + m_rhs) - ynew;\n    }\n\n    void DoStep(double tau, VectorView<double> y) override\n    {\n      m_yold->set(y);\n      m_tau_half->set(0.5 * tau);\n\n      this->m_rhs->evaluate(y, m_vecf);\n      m_fold->set(m_vecf);\n\n      NewtonSolver(m_equ, y);\n    }\n  };","type":"content","url":"/crank-nicolson#crank-nicolson","position":5},{"hierarchy":{"lvl1":"Crank‚ÄìNicolson Method","lvl2":"Comparison"},"type":"lvl2","url":"/crank-nicolson#comparison","position":6},{"hierarchy":{"lvl1":"Crank‚ÄìNicolson Method","lvl2":"Comparison"},"content":"\n\n\n\nThis is a simple mass‚Äìspring system, therefore the energy should be constant and the movement periodic. In state space, this would appear as a perfect ellipse. However, as we can see, this is not the case for the implicit and explicit Euler methods.The explicit method increases the speed at each step relatively quickly, and similarly, the implicit method decreases the velocity with each step, almost as if the system were damped. Both of these effects decrease with an increase in step size.\n\nBy far the best method in this example is the Crank‚ÄìNicolson method, as it seems to keep the energy in the system constant.","type":"content","url":"/crank-nicolson#comparison","position":7},{"hierarchy":{"lvl1":"Crank‚ÄìNicolson Method","lvl2":"RC-Circuit"},"type":"lvl2","url":"/crank-nicolson#rc-circuit","position":8},{"hierarchy":{"lvl1":"Crank‚ÄìNicolson Method","lvl2":"RC-Circuit"},"content":"The RC circuit is modelled by the formula:U_0(t)=cos(100\\pi t)U_C(t) + R C \\frac{dU_C}{dt}(t) = U_0(t)\n\nTo bring this into an autonomous form, we treat t as a state variable and setx = t.\n\nThen the right-hand side becomesU_0(x) = \\cos(100\\pi x),\n\nand the ODE can be rewritten asU_C'(t) = \\frac{\\cos(100\\pi x) - U_C(t)}{RC},x'(t) = 1.\n\nThis RC-Circuit was implemented as a class in \n\ntimestepper.hppclass RCCircuit: public NonlinearFunction\n{\nprivate:\n  double R;\n  double C;\n\npublic:\n  RCCircuit(double R_, double C_) : R(R_), C(C_) {}\n\n  size_t dimX() const override { return 2; }\n  size_t dimF() const override { return 2; }\n  \n  void evaluate (VectorView<double> x, VectorView<double> f) const override\n  {\n    double Uc = x(0);   // capacitor voltage\n    double t  = x(1);   // time\n\n    f(0) = (std::cos(100.0*t*M_PI) - Uc)/(R*C);\n    f(1) = 1.0;\n  }\n  \n  void evaluateDeriv (VectorView<double> x, MatrixView<double> df) const override\n  {\n    df = 0.0;\n    //derivatives with respect to the first state variable (Uc)\n    df(0,0) = -1.0 / (R * C);\n    df(1,0) = 0.0;\n    //derivative with respect to the second state variable (t)\n    df(0,1) = -100.0 * M_PI * std::sin(100.0 * x(1)) / (R * C);\n    df(1,1) = 0.0;\n\n  }\n};","type":"content","url":"/crank-nicolson#rc-circuit","position":9},{"hierarchy":{"lvl1":"Crank‚ÄìNicolson Method","lvl3":"Plots","lvl2":"RC-Circuit"},"type":"lvl3","url":"/crank-nicolson#plots","position":10},{"hierarchy":{"lvl1":"Crank‚ÄìNicolson Method","lvl3":"Plots","lvl2":"RC-Circuit"},"content":"In the plots, one can observe a similar trend as in the mass‚Äìspring system.The explicit Euler method has too much energy, while the implicit Euler method has too little.\nHowever, unlike in the mass‚Äìspring case, both numerical solutions remain periodic, so the energy no longer grows or decays over time.\n\nOn the left we set the parameters to R=1, C=1 and on the right R=100, C=10^-6\n\n \n\n \n\n ","type":"content","url":"/crank-nicolson#plots","position":11},{"hierarchy":{"lvl1":"Euler Methods"},"type":"lvl1","url":"/euler-methods","position":0},{"hierarchy":{"lvl1":"Euler Methods"},"content":"Exercise 17.2.2","type":"content","url":"/euler-methods","position":1},{"hierarchy":{"lvl1":"Euler Methods","lvl2":"Explicit Euler"},"type":"lvl2","url":"/euler-methods#explicit-euler","position":2},{"hierarchy":{"lvl1":"Euler Methods","lvl2":"Explicit Euler"},"content":"The Explicit Euler method has been implemented in Exercise_17_2_2.cpp. The method is defined as:y_{n+1} = y_n + \\tau f(y_n)\n\nwhere (y) is the state vector ([y, v]^T) (position and velocity), and (f(y_n)) is the right-hand side of the mass-spring ODE:\\frac{dy}{dt} = v, \\quad \\frac{dv}{dt} = -y\n\nThe implementation updates the state at each timestep as follows:State f = rhs(y);\ny.y += tau * f.y;\ny.v += tau * f.v;","type":"content","url":"/euler-methods#explicit-euler","position":3},{"hierarchy":{"lvl1":"Euler Methods","lvl2":"Improved Euler (Midpoint-Like)"},"type":"lvl2","url":"/euler-methods#improved-euler-midpoint-like","position":4},{"hierarchy":{"lvl1":"Euler Methods","lvl2":"Improved Euler (Midpoint-Like)"},"content":"The Improved Euler method is a two-stage method, which uses a midpoint-like estimate:\\tilde{y} = y_n + \\frac{\\tau}{2} f(y_n)y_{n+1} = y_n + \\tau f(\\tilde{y})\n\nThis improves the accuracy compared to the simple Explicit Euler. In the code, the implementation is:State f = rhs(y);\nState ytilde;\nytilde.y = y.y + 0.5 * tau * f.y;\nytilde.v = y.v + 0.5 * tau * f.v;\nState f2 = rhs(ytilde);\ny.y += tau * f2.y;\ny.v += tau * f2.v;","type":"content","url":"/euler-methods#improved-euler-midpoint-like","position":5},{"hierarchy":{"lvl1":"Euler Methods","lvl2":"Analytical Solution"},"type":"lvl2","url":"/euler-methods#analytical-solution","position":6},{"hierarchy":{"lvl1":"Euler Methods","lvl2":"Analytical Solution"},"content":"For the mass-spring system with (m = k = 1) and initial conditions (y(0)=1, v(0)=0), the analytical solution is:y(t) = \\cos(t), \\quad v(t) = -\\sin(t)\n\nWe use this to compute errors and energy deviations.","type":"content","url":"/euler-methods#analytical-solution","position":7},{"hierarchy":{"lvl1":"Euler Methods","lvl2":"Comparison"},"type":"lvl2","url":"/euler-methods#comparison","position":8},{"hierarchy":{"lvl1":"Euler Methods","lvl2":"Comparison"},"content":"","type":"content","url":"/euler-methods#comparison","position":9},{"hierarchy":{"lvl1":"Euler Methods","lvl3":"Time Evolution","lvl2":"Comparison"},"type":"lvl3","url":"/euler-methods#time-evolution","position":10},{"hierarchy":{"lvl1":"Euler Methods","lvl3":"Time Evolution","lvl2":"Comparison"},"content":"Both methods were run for (T = 20) with 200 steps ((\\tau = 0.1)).\n\nExplicit Euler shows a gradual drift in energy and slightly increasing amplitude over time.\n\nImproved Euler remains much closer to the analytical solution, showing better energy conservation and phase accuracy.","type":"content","url":"/euler-methods#time-evolution","position":11},{"hierarchy":{"lvl1":"Euler Methods","lvl3":"Energy Conservation","lvl2":"Comparison"},"type":"lvl3","url":"/euler-methods#energy-conservation","position":12},{"hierarchy":{"lvl1":"Euler Methods","lvl3":"Energy Conservation","lvl2":"Comparison"},"content":"Energy is computed as:E = \\frac{1}{2}v^2 + \\frac{1}{2}y^2\n\nFor each method, the energy deviations were tracked.\n\nExplicit Euler shows noticeable growth in energy over time.\n\nImproved Euler keeps energy oscillations around the exact value (0.5), confirming better stability.","type":"content","url":"/euler-methods#energy-conservation","position":13},{"hierarchy":{"lvl1":"Euler Methods","lvl3":"Errors","lvl2":"Comparison"},"type":"lvl3","url":"/euler-methods#errors","position":14},{"hierarchy":{"lvl1":"Euler Methods","lvl3":"Errors","lvl2":"Comparison"},"content":"Max-norm and RMS errors compared to the analytical solution:\n\nExplicit Euler:¬† ¬† :¬† max|y-y*| = 0.651,¬† max|v-v*| = 0.676,¬† RMS y = 0.259,¬† RMS v = 0.269Improved Euler:¬† max|y-y*| = 0.033,¬† max|v-v*| = 0.033,¬† RMS y = 0.012,¬† RMS v = 0.012\n\nNote: These values are from running Exercise_17_2_2.cpp with T=20, steps=200.","type":"content","url":"/euler-methods#errors","position":15},{"hierarchy":{"lvl1":"Euler Methods","lvl3":"CSV Output","lvl2":"Comparison"},"type":"lvl3","url":"/euler-methods#csv-output","position":16},{"hierarchy":{"lvl1":"Euler Methods","lvl3":"CSV Output","lvl2":"Comparison"},"content":"The program generates CSV files for plotting:\n\nexplicit_euler.csv ‚Äì time evolution of position and velocity for Explicit Euler\n\nimproved_euler.csv ‚Äì time evolution for Improved Euler\n\nenergy_comparison.csv ‚Äì energies of both methods vs. exact energy\n\nThese CSV files can be used to produce plots of (y(t)), (v(t)), phase-space trajectories, and energy evolution.","type":"content","url":"/euler-methods#csv-output","position":17},{"hierarchy":{"lvl1":"Euler Methods","lvl2":"Summary"},"type":"lvl2","url":"/euler-methods#summary","position":18},{"hierarchy":{"lvl1":"Euler Methods","lvl2":"Summary"},"content":"The Explicit Euler method is simple but suffers from energy drift in oscillatory systems.\n\nThe Improved Euler method provides much higher accuracy and better energy conservation for the mass-spring problem.\n\nUsing analytical solutions allows easy validation of numerical methods.\n\nThe implementation demonstrates how even a small improvement in the integration scheme can greatly enhance stability and accuracy for mechanical oscillators.","type":"content","url":"/euler-methods#summary","position":19},{"hierarchy":{"lvl1":"Applications of Newmark"},"type":"lvl1","url":"/newmark","position":0},{"hierarchy":{"lvl1":"Applications of Newmark"},"content":"The following examples have been created:","type":"content","url":"/newmark","position":1},{"hierarchy":{"lvl1":"Applications of Newmark","lvl2":"A Chain"},"type":"lvl2","url":"/newmark#a-chain","position":2},{"hierarchy":{"lvl1":"Applications of Newmark","lvl2":"A Chain"},"content":"","type":"content","url":"/newmark#a-chain","position":3},{"hierarchy":{"lvl1":"Applications of Newmark","lvl2":"A Crane"},"type":"lvl2","url":"/newmark#a-crane","position":4},{"hierarchy":{"lvl1":"Applications of Newmark","lvl2":"A Crane"},"content":"","type":"content","url":"/newmark#a-crane","position":5},{"hierarchy":{"lvl1":"Applications of Newmark","lvl2":"A Spinning Top"},"type":"lvl2","url":"/newmark#a-spinning-top","position":6},{"hierarchy":{"lvl1":"Applications of Newmark","lvl2":"A Spinning Top"},"content":"","type":"content","url":"/newmark#a-spinning-top","position":7},{"hierarchy":{"lvl1":"Runge Kutta"},"type":"lvl1","url":"/runge-kutta","position":0},{"hierarchy":{"lvl1":"Runge Kutta"},"content":"\\begin{aligned}\n    y‚Ä≤(t)=‚àíy(t), \\\\\n    y(0)=1  \n\\end{aligned}\n\nIts analytical solution is:y(t)=e^{‚àít}\n\nThe numerical methods to be compared are:\n\nExplicit RK2 (Midpoint)\n\nExplicit RK4\n\nImplicit Gauss-Legendre 2-stage (s=2)\n\nImplicit Radau IIA 2-stage (s=2)\n\nWe compute the approximate values and errors at each time step\n\nPrinciples of the Four MethodsRK2 (Midpoint)\n\nType: Explicit second-order Runge-Kutta\n\nStep formula:\\begin{aligned}\n    k_1‚Äã=f(t_n‚Äã,y_n‚Äã), \\\\\n    k_2‚Äã=f(t_n‚Äã +h/2,y_n‚Äã+h k_1‚Äã/2), \\\\ \n    y_{n+1}‚Äã=y_n+h k_2‚Äã  \n\\end{aligned}\n\nCharacteristics: second-order convergence, explicit computation.RK4\n\nType: Explicit fourth-order Runge-Kutta\n\nStep formula:\\begin{aligned}\n    k_1‚Äã=f(t_n‚Äã,y_n‚Äã), \\\\\n    k_2‚Äã=f(t_n‚Äã+h/2,y_n‚Äã+h k_1‚Äã/2), \\\\\n    k_3‚Äã=f(t_n‚Äã+h/2,y_n‚Äã+h k_2‚Äã/2), \\\\\n    k_4‚Äã=f(t_n‚Äã + h,y_n‚Äã+h k_3‚Äã), \\\\\n    y_{n+1}‚Äã=y_n‚Äã+6/h‚Äã(k_1‚Äã+2 k_2‚Äã+2 k_3‚Äã+k_4)  \n\\end{aligned}\n\nCaracteristics: fourth-order convergence, explicit, higher accuracy than RK2.Gauss-Legendre 2-stage\n\nType: Implicit two-stage Gauss-Legendre Runge-Kutta\n\nUses two nodes (s=2) in a high-order implicit integration formula\n\nEach step requires solving a nonlinear system (fixed-point iteration or Newton iteration)\n\nCharacteristics: A-stable, second-order accuracy, implicit computation.\n\nRadau IIA 2-stage\n\nType: Implicit Radau IIA Runge-Kutta\n\nTwo nodes, implicit method\n\nSuitable for stiff ODEs, A-stable and second-order accurate\n\nStep requires solving a nonlinear system.\n\nError Comparison and ResultsCalculation conditions:\n\nFinal time ùëá = 1.0\n\nNumber of steps ùëÅ = 10 (step size ‚Ñé=0.1)\n\nSample numerical results:\n\nt\n\nRK2\n\nerror\n\nRK4\n\nerror\n\nGL2\n\nerror\n\nRadau2\n\nerror\n\n0.0\n\n1.00000000\n\n0.00000000\n\n1.00000000\n\n0.00000000\n\n1.00000000\n\n0.00000000\n\n1.00000000\n\n0.00000000\n\n0.1\n\n0.90500000\n\n0.00016258\n\n0.90483750\n\n0.00000008\n\n0.90483743\n\n0.00000001\n\n0.90483619\n\n0.00000122\n\n0.2\n\n0.81902500\n\n0.00029425\n\n0.81873090\n\n0.00000015\n\n0.81873078\n\n0.00000002\n\n0.81872854\n\n0.00000222\n\n0.3\n\n0.74121762\n\n0.00039940\n\n0.74081842\n\n0.00000020\n\n0.74081825\n\n0.00000003\n\n0.74081521\n\n0.00000301\n\n0.4\n\n0.67080195\n\n0.00048190\n\n0.67032029\n\n0.00000024\n\n0.67032008\n\n0.00000004\n\n0.67031642\n\n0.00000363\n\n0.5\n\n0.60707577\n\n0.00054511\n\n0.60653093\n\n0.00000027\n\n0.60653070\n\n0.00000004\n\n0.60652656\n\n0.00000410\n\n0.6\n\n0.54940357\n\n0.00059193\n\n0.54881193\n\n0.00000030\n\n0.54881168\n\n0.00000005\n\n0.54880718\n\n0.00000446\n\n0.7\n\n0.49721023\n\n0.00062492\n\n0.49658562\n\n0.00000031\n\n0.49658535\n\n0.00000005\n\n0.49658060\n\n0.00000470\n\n0.8\n\n0.44997526\n\n0.00064629\n\n0.44932929\n\n0.00000033\n\n0.44932901\n\n0.00000005\n\n0.44932410\n\n0.00000486\n\n0.9\n\n0.40722761\n\n0.00065795\n\n0.40656999\n\n0.00000033\n\n0.40656971\n\n0.00000005\n\n0.40656471\n\n0.00000495\n\n1.0\n\n0.36854098\n\n0.00066154\n\n0.36787977\n\n0.00000033\n\n0.36787949\n\n0.00000005\n\n0.36787446\n\n0.00000498\n\nObservations:\n\nRK2 exhibits larger errors, deviating noticeably from the exact solution.\n\nRK4 has very small errors, demonstrating clear advantage of fourth-order convergence.\n\nGauss-Legendre 2-stage and Radau IIA 2-stage have very small errors, comparable to RK4, and are A-stable implicit methods.\n\nReducing step size decreases the errors of RK4, GL2, and Radau2 rapidly, while RK2 decreases more slowly.\n\nConclusiona. Explicit methods:\n\nRK2 has limited accuracy, suitable for non-stiff ODEs with low precision requirements.\n\nRK4 is fourth-order accurate, computationally efficient, and suitable for general non-stiff problems.\n\nb. Implicit methods:\n\nGauss-Legendre and Radau IIA are more stable for stiff problems (A-stable).\n\nAccuracy is comparable to RK4, and larger step sizes can be used without divergence.\n\nc. Summary:\n\nFor non-stiff ODEs with high accuracy requirements, RK4 is the simplest and most effective choice.\n\nFor stiff ODEs or when larger step sizes are desired, implicit methods (Gauss-Legendre / Radau IIA) are more appropriate.","type":"content","url":"/runge-kutta","position":1},{"hierarchy":{"lvl1":"Welcome to ASC-ODE_team-04‚Äôs documentation!"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"Welcome to ASC-ODE_team-04‚Äôs documentation!"},"content":"ASC-ODE_team-04 is is a C++ library for solving ordinary differential equations (ODEs).\nThe equation is defined by the right hand side function.\nASC-ODE provides various time-steppers which may be used for odes with right hand sides\ngiven by a function object.\n\nA small demo for solving a mass-spring model as first order ODEy_0^\\prime & = & y_1 \\\\\ny_1^\\prime & = & -\\frac{k}{m} y_0\n\nis here:double tend = 4*M_PI;\nint steps = 100;\ndouble tau = tend/steps;\n\nVector<> y = { 1, 0 };  // initial conditions\nshared_ptr<NonlinearFunction> rhs = std::make_shared<MassSpring>(mass, stiffness);\n  \nExplicitEuler stepper(rhs);\n\nstd::cout << 0.0 << \"  \" << y(0) << \" \" << y(1) << std::endl;\nfor (int i = 0; i < steps; i++)\n  {\n     stepper.DoStep(tau, y);\n     std::cout << (i+1) * tau << \"  \" << y(0) << \" \" << y(1) << std::endl;\n  }\n\nThe result of this simulation in phase space is shown here:","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"Welcome to ASC-ODE_team-04‚Äôs documentation!","lvl2":"Installation"},"type":"lvl2","url":"/#installation","position":2},{"hierarchy":{"lvl1":"Welcome to ASC-ODE_team-04‚Äôs documentation!","lvl2":"Installation"},"content":"install ASC-ODE_team-04 via git-clone:git clone https://github.com/strasser-lab/ASC-ODE-team04.git\n\nTo configure and build some tests docd ASC-ODE-team04\nmkdir build\ncd build\ncmake ..\nmake","type":"content","url":"/#installation","position":3},{"hierarchy":{"lvl1":"Welcome to ASC-ODE_team-04‚Äôs documentation!","lvl2":"Available time-stepping methods are"},"type":"lvl2","url":"/#available-time-stepping-methods-are","position":4},{"hierarchy":{"lvl1":"Welcome to ASC-ODE_team-04‚Äôs documentation!","lvl2":"Available time-stepping methods are"},"content":"Explicit Euler\n\nImplicit Euler\n\nCrank Nicolson\n\nRungne Kutter\n\nNewmark\n\nThese are explained in there respective chapters, alongside the exercises we had to do.","type":"content","url":"/#available-time-stepping-methods-are","position":5}]}