{"version":"1","records":[{"hierarchy":{"lvl1":"Exercise 17.2.2"},"type":"lvl1","url":"/exercise17-2-2","position":0},{"hierarchy":{"lvl1":"Exercise 17.2.2"},"content":"In this exercise we had to:\n\nImplement the Explicit Euler method.\n\nImplement the Improved Euler (midpoint-like) method.\n\nCompare the methods in terms of accuracy and energy conservation for a mass-spring system.","type":"content","url":"/exercise17-2-2","position":1},{"hierarchy":{"lvl1":"Exercise 17.2.2","lvl2":"Methods Implemented"},"type":"lvl2","url":"/exercise17-2-2#methods-implemented","position":2},{"hierarchy":{"lvl1":"Exercise 17.2.2","lvl2":"Methods Implemented"},"content":"","type":"content","url":"/exercise17-2-2#methods-implemented","position":3},{"hierarchy":{"lvl1":"Exercise 17.2.2","lvl3":"Explicit Euler","lvl2":"Methods Implemented"},"type":"lvl3","url":"/exercise17-2-2#explicit-euler","position":4},{"hierarchy":{"lvl1":"Exercise 17.2.2","lvl3":"Explicit Euler","lvl2":"Methods Implemented"},"content":"The Explicit Euler method has been implemented in Exercise_17_2_2.cpp. The method is defined as:y_{n+1} = y_n + \\tau f(y_n)\n\nwhere (y) is the state vector ([y, v]^T) (position and velocity), and (f(y_n)) is the right-hand side of the mass-spring ODE:\\frac{dy}{dt} = v, \\quad \\frac{dv}{dt} = -y\n\nThe implementation updates the state at each timestep as follows:State f = rhs(y);\ny.y += tau * f.y;\ny.v += tau * f.v;","type":"content","url":"/exercise17-2-2#explicit-euler","position":5},{"hierarchy":{"lvl1":"Exercise 17.2.2","lvl3":"Improved Euler (Midpoint-Like)","lvl2":"Methods Implemented"},"type":"lvl3","url":"/exercise17-2-2#improved-euler-midpoint-like","position":6},{"hierarchy":{"lvl1":"Exercise 17.2.2","lvl3":"Improved Euler (Midpoint-Like)","lvl2":"Methods Implemented"},"content":"The Improved Euler method is a two-stage method, which uses a midpoint-like estimate:\\tilde{y} = y_n + \\frac{\\tau}{2} f(y_n)y_{n+1} = y_n + \\tau f(\\tilde{y})\n\nThis improves the accuracy compared to the simple Explicit Euler. In the code, the implementation is:State f = rhs(y);\nState ytilde;\nytilde.y = y.y + 0.5 * tau * f.y;\nytilde.v = y.v + 0.5 * tau * f.v;\nState f2 = rhs(ytilde);\ny.y += tau * f2.y;\ny.v += tau * f2.v;","type":"content","url":"/exercise17-2-2#improved-euler-midpoint-like","position":7},{"hierarchy":{"lvl1":"Exercise 17.2.2","lvl3":"Analytical Solution","lvl2":"Methods Implemented"},"type":"lvl3","url":"/exercise17-2-2#analytical-solution","position":8},{"hierarchy":{"lvl1":"Exercise 17.2.2","lvl3":"Analytical Solution","lvl2":"Methods Implemented"},"content":"For the mass-spring system with (m = k = 1) and initial conditions (y(0)=1, v(0)=0), the analytical solution is:y(t) = \\cos(t), \\quad v(t) = -\\sin(t)\n\nWe use this to compute errors and energy deviations.","type":"content","url":"/exercise17-2-2#analytical-solution","position":9},{"hierarchy":{"lvl1":"Exercise 17.2.2","lvl2":"Comparison"},"type":"lvl2","url":"/exercise17-2-2#comparison","position":10},{"hierarchy":{"lvl1":"Exercise 17.2.2","lvl2":"Comparison"},"content":"","type":"content","url":"/exercise17-2-2#comparison","position":11},{"hierarchy":{"lvl1":"Exercise 17.2.2","lvl3":"Time Evolution","lvl2":"Comparison"},"type":"lvl3","url":"/exercise17-2-2#time-evolution","position":12},{"hierarchy":{"lvl1":"Exercise 17.2.2","lvl3":"Time Evolution","lvl2":"Comparison"},"content":"Both methods were run for (T = 20) with 200 steps ((\\tau = 0.1)).\n\nExplicit Euler shows a gradual drift in energy and slightly increasing amplitude over time.\n\nImproved Euler remains much closer to the analytical solution, showing better energy conservation and phase accuracy.","type":"content","url":"/exercise17-2-2#time-evolution","position":13},{"hierarchy":{"lvl1":"Exercise 17.2.2","lvl3":"Energy Conservation","lvl2":"Comparison"},"type":"lvl3","url":"/exercise17-2-2#energy-conservation","position":14},{"hierarchy":{"lvl1":"Exercise 17.2.2","lvl3":"Energy Conservation","lvl2":"Comparison"},"content":"Energy is computed as:E = \\frac{1}{2}v^2 + \\frac{1}{2}y^2\n\nFor each method, the energy deviations were tracked.\n\nExplicit Euler shows noticeable growth in energy over time.\n\nImproved Euler keeps energy oscillations around the exact value (0.5), confirming better stability.","type":"content","url":"/exercise17-2-2#energy-conservation","position":15},{"hierarchy":{"lvl1":"Exercise 17.2.2","lvl3":"Errors","lvl2":"Comparison"},"type":"lvl3","url":"/exercise17-2-2#errors","position":16},{"hierarchy":{"lvl1":"Exercise 17.2.2","lvl3":"Errors","lvl2":"Comparison"},"content":"Max-norm and RMS errors compared to the analytical solution:\n\nExplicit Euler:¬† ¬† :¬† max|y-y*| = 0.651,¬† max|v-v*| = 0.676,¬† RMS y = 0.259,¬† RMS v = 0.269Improved Euler:¬† max|y-y*| = 0.033,¬† max|v-v*| = 0.033,¬† RMS y = 0.012,¬† RMS v = 0.012\n\nNote: These values are from running Exercise_17_2_2.cpp with T=20, steps=200.","type":"content","url":"/exercise17-2-2#errors","position":17},{"hierarchy":{"lvl1":"Exercise 17.2.2","lvl3":"CSV Output","lvl2":"Comparison"},"type":"lvl3","url":"/exercise17-2-2#csv-output","position":18},{"hierarchy":{"lvl1":"Exercise 17.2.2","lvl3":"CSV Output","lvl2":"Comparison"},"content":"The program generates CSV files for plotting:\n\nexplicit_euler.csv ‚Äì time evolution of position and velocity for Explicit Euler\n\nimproved_euler.csv ‚Äì time evolution for Improved Euler\n\nenergy_comparison.csv ‚Äì energies of both methods vs. exact energy\n\nThese CSV files can be used to produce plots of (y(t)), (v(t)), phase-space trajectories, and energy evolution.","type":"content","url":"/exercise17-2-2#csv-output","position":19},{"hierarchy":{"lvl1":"Exercise 17.2.2","lvl2":"Summary"},"type":"lvl2","url":"/exercise17-2-2#summary","position":20},{"hierarchy":{"lvl1":"Exercise 17.2.2","lvl2":"Summary"},"content":"The Explicit Euler method is simple but suffers from energy drift in oscillatory systems.\n\nThe Improved Euler method provides much higher accuracy and better energy conservation for the mass-spring problem.\n\nUsing analytical solutions allows easy validation of numerical methods.\n\nThe implementation demonstrates how even a small improvement in the integration scheme can greatly enhance stability and accuracy for mechanical oscillators.","type":"content","url":"/exercise17-2-2#summary","position":21},{"hierarchy":{"lvl1":"Exercise 17.4.1"},"type":"lvl1","url":"/exercise17-4-1","position":0},{"hierarchy":{"lvl1":"Exercise 17.4.1"},"content":"In this exercise we had to:\n\nimplement the Crank‚ÄìNicolson method\n\ncompare the three methods to each other\n\nuse the three methods to solve an electronic network","type":"content","url":"/exercise17-4-1","position":1},{"hierarchy":{"lvl1":"Exercise 17.4.1","lvl2":"Crank‚ÄìNicolson"},"type":"lvl2","url":"/exercise17-4-1#crank-nicolson","position":2},{"hierarchy":{"lvl1":"Exercise 17.4.1","lvl2":"Crank‚ÄìNicolson"},"content":"The Crank‚ÄìNicolson method has been implemented in\n\ntimestepper.hpp.\n\nThe method is defined as:y_{i+1} = y_i + \\frac{\\tau}{2}\\big(f(t_i, y_i) + f(t_{i+1}, y_{i+1})\\big)\n\nTo achieve this, we adapted the code for the implicit and explicit Euler methods and implemented the formula above.\n  class CrankNicolson : public TimeStepper\n  {\n    std::shared_ptr<NonlinearFunction> m_equ;\n    std::shared_ptr<Parameter> m_tau_half;\n    std::shared_ptr<ConstantFunction> m_yold;\n    Vector<> m_vecf;\n    std::shared_ptr<ConstantFunction> m_fold;\n  public:\n    CrankNicolson(std::shared_ptr<NonlinearFunction> rhs) \n    : TimeStepper(rhs), m_tau_half(std::make_shared<Parameter>(0.0)) \n      , m_vecf(rhs->dimF())\n    {\n      m_yold = std::make_shared<ConstantFunction>(rhs->dimX());\n      m_fold = std::make_shared<ConstantFunction>(rhs->dimF());\n      auto ynew = std::make_shared<IdentityFunction>(rhs->dimX());\n      m_equ = m_yold + m_tau_half * (m_fold + m_rhs) - ynew;\n    }\n\n    void DoStep(double tau, VectorView<double> y) override\n    {\n      m_yold->set(y);\n      m_tau_half->set(0.5 * tau);\n\n      this->m_rhs->evaluate(y, m_vecf);\n      m_fold->set(m_vecf);\n\n      NewtonSolver(m_equ, y);\n    }\n  };","type":"content","url":"/exercise17-4-1#crank-nicolson","position":3},{"hierarchy":{"lvl1":"Exercise 17.4.1","lvl2":"Comparison"},"type":"lvl2","url":"/exercise17-4-1#comparison","position":4},{"hierarchy":{"lvl1":"Exercise 17.4.1","lvl2":"Comparison"},"content":"\n\n\n\nThis is a simple mass‚Äìspring system, therefore the energy should be constant and the movement periodic. In state space, this would appear as a perfect ellipse. However, as we can see, this is not the case for the implicit and explicit Euler methods.The explicit method increases the speed at each step relatively quickly, and similarly, the implicit method decreases the velocity with each step, almost as if the system were damped. Both of these effects decrease with an increase in step size.\n\nBy far the best method in this example is the Crank‚ÄìNicolson method, as it seems to keep the energy in the system constant.","type":"content","url":"/exercise17-4-1#comparison","position":5},{"hierarchy":{"lvl1":"Exercise 17.4.1","lvl2":"RC-Circuit"},"type":"lvl2","url":"/exercise17-4-1#rc-circuit","position":6},{"hierarchy":{"lvl1":"Exercise 17.4.1","lvl2":"RC-Circuit"},"content":"The RC circuit is modelled by the formula:U_0(t)=cos(100\\pi t)U_C(t) + R C \\frac{dU_C}{dt}(t) = U_0(t)\n\nTo bring this into an autonomous form, we treat t as a state variable and setx = t.\n\nThen the right-hand side becomesU_0(x) = \\cos(100\\pi x),\n\nand the ODE can be rewritten asU_C'(t) = \\frac{\\cos(100\\pi x) - U_C(t)}{RC},x'(t) = 1.\n\nThis RC-Circuit was implemented as a class in \n\ntimestepper.hppclass RCCircuit: public NonlinearFunction\n{\nprivate:\n  double R;\n  double C;\n\npublic:\n  RCCircuit(double R_, double C_) : R(R_), C(C_) {}\n\n  size_t dimX() const override { return 2; }\n  size_t dimF() const override { return 2; }\n  \n  void evaluate (VectorView<double> x, VectorView<double> f) const override\n  {\n    double Uc = x(0);   // capacitor voltage\n    double t  = x(1);   // time\n\n    f(0) = (std::cos(100.0*t*M_PI) - Uc)/(R*C);\n    f(1) = 1.0;\n  }\n  \n  void evaluateDeriv (VectorView<double> x, MatrixView<double> df) const override\n  {\n    df = 0.0;\n    //derivatives with respect to the first state variable (Uc)\n    df(0,0) = -1.0 / (R * C);\n    df(1,0) = 0.0;\n    //derivative with respect to the second state variable (t)\n    df(0,1) = -100.0 * M_PI * std::sin(100.0 * x(1)) / (R * C);\n    df(1,1) = 0.0;\n\n  }\n};","type":"content","url":"/exercise17-4-1#rc-circuit","position":7},{"hierarchy":{"lvl1":"Exercise 17.4.1","lvl3":"Plots","lvl2":"RC-Circuit"},"type":"lvl3","url":"/exercise17-4-1#plots","position":8},{"hierarchy":{"lvl1":"Exercise 17.4.1","lvl3":"Plots","lvl2":"RC-Circuit"},"content":"In the plots, one can observe a similar trend as in the mass‚Äìspring system.The explicit Euler method has too much energy, while the implicit Euler method has too little.\nHowever, unlike in the mass‚Äìspring case, both numerical solutions remain periodic, so the energy no longer grows or decays over time.\n\nOn the left we set the parameters to R=1, C=1 and on the right R=100, C=10^-6\n\n \n\n \n\n ","type":"content","url":"/exercise17-4-1#plots","position":9},{"hierarchy":{"lvl1":"Exercise 18.4"},"type":"lvl1","url":"/exercise-18-4","position":0},{"hierarchy":{"lvl1":"Exercise 18.4"},"content":"In this exercise we had to:\n\nAdd additional useful operators for the AutoDiff class\n\nAdd some more functions (cos, exp, log, ‚Ä¶) for the AutoDiff class.\n\nEvaluate and plot Legendre-polynomials up to order 5, in the interval -1 \\le x \\le 1. Evaluate and plot also their derivatives (using AutoDiff).","type":"content","url":"/exercise-18-4","position":1},{"hierarchy":{"lvl1":"Exercise 18.4","lvl2":"Implemented operators/functions (subtask 1, 2)"},"type":"lvl2","url":"/exercise-18-4#implemented-operators-functions-subtask-1-2","position":2},{"hierarchy":{"lvl1":"Exercise 18.4","lvl2":"Implemented operators/functions (subtask 1, 2)"},"content":"We implemented some useful operators and functions for the AutoDiff class in the autodiff.hpp.","type":"content","url":"/exercise-18-4#implemented-operators-functions-subtask-1-2","position":3},{"hierarchy":{"lvl1":"Exercise 18.4","lvl3":"Arithmetic operators","lvl2":"Implemented operators/functions (subtask 1, 2)"},"type":"lvl3","url":"/exercise-18-4#arithmetic-operators","position":4},{"hierarchy":{"lvl1":"Exercise 18.4","lvl3":"Arithmetic operators","lvl2":"Implemented operators/functions (subtask 1, 2)"},"content":"We have:\n\\\\ u(x) and its derivative u' \\\\\nv(x) and its derivative v' \\\\\n\nThen,","type":"content","url":"/exercise-18-4#arithmetic-operators","position":5},{"hierarchy":{"lvl1":"Exercise 18.4","lvl4":"Addition","lvl3":"Arithmetic operators","lvl2":"Implemented operators/functions (subtask 1, 2)"},"type":"lvl4","url":"/exercise-18-4#addition","position":6},{"hierarchy":{"lvl1":"Exercise 18.4","lvl4":"Addition","lvl3":"Arithmetic operators","lvl2":"Implemented operators/functions (subtask 1, 2)"},"content":"Mathematics:f(x) = u(x) + v(x), \\quad f'(x) = u' + v'\n\nExample:f(x) = x^2 + 3x \\Rightarrow f'(x) = 2x + 3\n\nIn the code the implementation is:template <typename T>\nAutoDiff<T> operator+(const AutoDiff<T>& a, const AutoDiff<T>& b) {\n    return AutoDiff<T>(a.val + b.val, a.der + b.der);\n}","type":"content","url":"/exercise-18-4#addition","position":7},{"hierarchy":{"lvl1":"Exercise 18.4","lvl4":"Subtraction","lvl3":"Arithmetic operators","lvl2":"Implemented operators/functions (subtask 1, 2)"},"type":"lvl4","url":"/exercise-18-4#subtraction","position":8},{"hierarchy":{"lvl1":"Exercise 18.4","lvl4":"Subtraction","lvl3":"Arithmetic operators","lvl2":"Implemented operators/functions (subtask 1, 2)"},"content":"Mathematics:f(x) = u(x) - v(x), \\quad f'(x) = u' - v'\n\nExample:f(x) = x^2 - \\sin(x) \\Rightarrow f'(x) = 2x - \\cos(x)\n\nIn the code the implementation is:template <typename T>\nAutoDiff<T> operator-(const AutoDiff<T>& a, const AutoDiff<T>& b) {\n    return AutoDiff<T>(a.val - b.val, a.der - b.der);\n}","type":"content","url":"/exercise-18-4#subtraction","position":9},{"hierarchy":{"lvl1":"Exercise 18.4","lvl4":"Multiplication","lvl3":"Arithmetic operators","lvl2":"Implemented operators/functions (subtask 1, 2)"},"type":"lvl4","url":"/exercise-18-4#multiplication","position":10},{"hierarchy":{"lvl1":"Exercise 18.4","lvl4":"Multiplication","lvl3":"Arithmetic operators","lvl2":"Implemented operators/functions (subtask 1, 2)"},"content":"Mathematics:f(x) = u(x) \\cdot v(x), \\quad f'(x) = u'v + uv'\n\nExample:f(x) = x \\cdot \\sin(x) \\Rightarrow f'(x) = \\sin(x) + x\\cos(x)\n\nIn the code the implementation is:template <typename T>\nAutoDiff<T> operator*(const AutoDiff<T>& a, const AutoDiff<T>& b) {\n    return AutoDiff<T>(a.val * b.val, a.der * b.val + a.val * b.der);\n}","type":"content","url":"/exercise-18-4#multiplication","position":11},{"hierarchy":{"lvl1":"Exercise 18.4","lvl4":"Division","lvl3":"Arithmetic operators","lvl2":"Implemented operators/functions (subtask 1, 2)"},"type":"lvl4","url":"/exercise-18-4#division","position":12},{"hierarchy":{"lvl1":"Exercise 18.4","lvl4":"Division","lvl3":"Arithmetic operators","lvl2":"Implemented operators/functions (subtask 1, 2)"},"content":"Mathematics:f(x) = \\frac{u(x)}{v(x)}, \\quad f'(x) = \\frac{u'v - uv'}{v^2}\n\nExample:f(x) = \\frac{x}{x + 1} \\Rightarrow f'(x) = \\frac{1}{(x + 1)^2}\n\nIn the code the implementation is:AutoDiff<T> operator/(const AutoDiff<T>& a, const AutoDiff<T>& b) {\n    T bv = b.val;\n    return AutoDiff<T>(a.val / bv,\n                       (a.der * bv - a.val * b.der) / (bv * bv));\n}","type":"content","url":"/exercise-18-4#division","position":13},{"hierarchy":{"lvl1":"Exercise 18.4","lvl4":"Negative sign","lvl3":"Arithmetic operators","lvl2":"Implemented operators/functions (subtask 1, 2)"},"type":"lvl4","url":"/exercise-18-4#negative-sign","position":14},{"hierarchy":{"lvl1":"Exercise 18.4","lvl4":"Negative sign","lvl3":"Arithmetic operators","lvl2":"Implemented operators/functions (subtask 1, 2)"},"content":"Mathematics:f(x) = -u(x), \\quad f'(x) = -u'\n\nExample:f(x) = \\cos(x) \\Rightarrow f'(x) = \\sin(x)\n\nIn the code the implementation is:template <typename T>\nAutoDiff<T> operator-(const AutoDiff<T>& a) {\n    return AutoDiff<T>(-a.val, -a.der);\n}","type":"content","url":"/exercise-18-4#negative-sign","position":15},{"hierarchy":{"lvl1":"Exercise 18.4","lvl3":"Elementary functions","lvl2":"Implemented operators/functions (subtask 1, 2)"},"type":"lvl3","url":"/exercise-18-4#elementary-functions","position":16},{"hierarchy":{"lvl1":"Exercise 18.4","lvl3":"Elementary functions","lvl2":"Implemented operators/functions (subtask 1, 2)"},"content":"Here we implemented the following useful elementary functions.\nWe have:\n\\\\ u(x) and its derivative u' \\\\\n\nThen,","type":"content","url":"/exercise-18-4#elementary-functions","position":17},{"hierarchy":{"lvl1":"Exercise 18.4","lvl4":"Sinus","lvl3":"Elementary functions","lvl2":"Implemented operators/functions (subtask 1, 2)"},"type":"lvl4","url":"/exercise-18-4#sinus","position":18},{"hierarchy":{"lvl1":"Exercise 18.4","lvl4":"Sinus","lvl3":"Elementary functions","lvl2":"Implemented operators/functions (subtask 1, 2)"},"content":"Mathematics:f(x) = \\sin(u(x)) \\Rightarrow f'(x) = \\cos(u(x)) \\cdot u'(x)\n\nExample:f(x) = \\sin(x) \\Rightarrow f'(x) = \\cos(x)\n\nIn the code the implementation is:template <typename T>\nAutoDiff<T> sin(const AutoDiff<T>& a) {\n    return AutoDiff<T>(std::sin(a.val), std::cos(a.val) * a.der);\n}","type":"content","url":"/exercise-18-4#sinus","position":19},{"hierarchy":{"lvl1":"Exercise 18.4","lvl4":"Cosinus","lvl3":"Elementary functions","lvl2":"Implemented operators/functions (subtask 1, 2)"},"type":"lvl4","url":"/exercise-18-4#cosinus","position":20},{"hierarchy":{"lvl1":"Exercise 18.4","lvl4":"Cosinus","lvl3":"Elementary functions","lvl2":"Implemented operators/functions (subtask 1, 2)"},"content":"Mathematics:f(x) = \\cos(u(x)) \\Rightarrow f'(x) = -\\sin(u(x)) \\cdot u'(x)\n\nExample:f(x) = \\cos(x) \\Rightarrow f'(x) = -\\sin(x)\n\nIn the code the implementation is:template <typename T>\nAutoDiff<T> cos(const AutoDiff<T>& a) {\n    return AutoDiff<T>(std::cos(a.val), -std::sin(a.val) * a.der);\n}","type":"content","url":"/exercise-18-4#cosinus","position":21},{"hierarchy":{"lvl1":"Exercise 18.4","lvl4":"Exponential","lvl3":"Elementary functions","lvl2":"Implemented operators/functions (subtask 1, 2)"},"type":"lvl4","url":"/exercise-18-4#exponential","position":22},{"hierarchy":{"lvl1":"Exercise 18.4","lvl4":"Exponential","lvl3":"Elementary functions","lvl2":"Implemented operators/functions (subtask 1, 2)"},"content":"Mathematics:f(x) = e^{u(x)} \\Rightarrow f'(x) = e^{u(x)} \\cdot u'(x)\n\nExample:f(x) = e^x \\Rightarrow f'(x) = e^x\n\nIn the code the implementation is:template <typename T>\nAutoDiff<T> exp(const AutoDiff<T>& a) {\n    T ev = std::exp(a.val);\n    return AutoDiff<T>(ev, ev * a.der);\n}","type":"content","url":"/exercise-18-4#exponential","position":23},{"hierarchy":{"lvl1":"Exercise 18.4","lvl4":"Logarithm","lvl3":"Elementary functions","lvl2":"Implemented operators/functions (subtask 1, 2)"},"type":"lvl4","url":"/exercise-18-4#logarithm","position":24},{"hierarchy":{"lvl1":"Exercise 18.4","lvl4":"Logarithm","lvl3":"Elementary functions","lvl2":"Implemented operators/functions (subtask 1, 2)"},"content":"Mathematics:f(x) = \\ln(u(x)) \\Rightarrow f'(x) = \\frac{u'(x)}{u(x)}\n\nExample:f(x) = \\ln(e^x) = x \\Rightarrow f'(x) = \\frac{1}{e^x} \\cdot e^x = 1\n\nIn the code the implementation is:template <typename T>\nAutoDiff<T> log(const AutoDiff<T>& a) {\n    return AutoDiff<T>(std::log(a.val), a.der / a.val);\n}","type":"content","url":"/exercise-18-4#logarithm","position":25},{"hierarchy":{"lvl1":"Exercise 18.4","lvl4":"Power","lvl3":"Elementary functions","lvl2":"Implemented operators/functions (subtask 1, 2)"},"type":"lvl4","url":"/exercise-18-4#power","position":26},{"hierarchy":{"lvl1":"Exercise 18.4","lvl4":"Power","lvl3":"Elementary functions","lvl2":"Implemented operators/functions (subtask 1, 2)"},"content":"Mathematics:f(x) = (u(x))^c \\Rightarrow f'(x) = c \\cdot (u(x))^{c-1} \\cdot u'(x)\n\nExample:f(x) = x^3 \\Rightarrow f'(x) = 3x^2\n\nIn the code the implementation is:template <typename T>\nAutoDiff<T> pow(const AutoDiff<T>& a, T exponent) {\n    T v = std::pow(a.val, exponent);\n    T factor = exponent * std::pow(a.val, exponent - 1);\n    return AutoDiff<T>(v, factor * a.der);\n}","type":"content","url":"/exercise-18-4#power","position":27},{"hierarchy":{"lvl1":"Exercise 18.4","lvl3":"Scalar operations","lvl2":"Implemented operators/functions (subtask 1, 2)"},"type":"lvl3","url":"/exercise-18-4#scalar-operations","position":28},{"hierarchy":{"lvl1":"Exercise 18.4","lvl3":"Scalar operations","lvl2":"Implemented operators/functions (subtask 1, 2)"},"content":"Here we implemented the following scalar operations.\nWe have:\n\\\\ u(x) and its derivative u' \\\\\nc as a scalar\n\nThen,","type":"content","url":"/exercise-18-4#scalar-operations","position":29},{"hierarchy":{"lvl1":"Exercise 18.4","lvl4":"Multiplication","lvl3":"Scalar operations","lvl2":"Implemented operators/functions (subtask 1, 2)"},"type":"lvl4","url":"/exercise-18-4#multiplication-1","position":30},{"hierarchy":{"lvl1":"Exercise 18.4","lvl4":"Multiplication","lvl3":"Scalar operations","lvl2":"Implemented operators/functions (subtask 1, 2)"},"content":"Mathematics:f(x) = c \\cdot u(x) \\Rightarrow f'(x) = c \\cdot u'(x)f(x) = u(x) \\cdot c \\Rightarrow f'(x) = u'(x) \\cdot c\n\nExample:f(x) = 5x \\Rightarrow f'(x) = 5\n\nIn the code the implementation is:template <typename T, typename S>\nAutoDiff<T> operator*(S scalar, const AutoDiff<T>& a) {\n    return AutoDiff<T>(scalar * a.val, scalar * a.der);\n}\n\ntemplate <typename T, typename S>\nAutoDiff<T> operator*(const AutoDiff<T>& a, S scalar) {\n    return scalar * a;\n}","type":"content","url":"/exercise-18-4#multiplication-1","position":31},{"hierarchy":{"lvl1":"Exercise 18.4","lvl4":"Addition","lvl3":"Scalar operations","lvl2":"Implemented operators/functions (subtask 1, 2)"},"type":"lvl4","url":"/exercise-18-4#addition-1","position":32},{"hierarchy":{"lvl1":"Exercise 18.4","lvl4":"Addition","lvl3":"Scalar operations","lvl2":"Implemented operators/functions (subtask 1, 2)"},"content":"Mathematics:f(x) = c + u(x) \\Rightarrow f'(x) = u'(x)f(x) = u(x) + c \\Rightarrow f'(x) = u'(x)\n\nExample:f(x) = x + 10 \\Rightarrow f'(x) = 1\n\nIn the code the implementation is:template <typename T, typename S>\nAutoDiff<T> operator+(S scalar, const AutoDiff<T>& a) {\n    return AutoDiff<T>(scalar + a.val, a.der);\n}\n\ntemplate <typename T, typename S>\nAutoDiff<T> operator+(const AutoDiff<T>& a, S scalar) {\n    return a + scalar;\n}","type":"content","url":"/exercise-18-4#addition-1","position":33},{"hierarchy":{"lvl1":"Exercise 18.4","lvl4":"Subtraction","lvl3":"Scalar operations","lvl2":"Implemented operators/functions (subtask 1, 2)"},"type":"lvl4","url":"/exercise-18-4#subtraction-1","position":34},{"hierarchy":{"lvl1":"Exercise 18.4","lvl4":"Subtraction","lvl3":"Scalar operations","lvl2":"Implemented operators/functions (subtask 1, 2)"},"content":"Mathematics:f(x) = c - u(x) \\Rightarrow f'(x) = -u'(x)f(x) = u(x) - c \\Rightarrow f'(x) = u'(x)\n\nExample:f(x) = 7 - x \\Rightarrow f'(x) = -1\n\nIn the code the implementation is:template <typename T, typename S>\nAutoDiff<T> operator-(S scalar, const AutoDiff<T>& a) {\n    return AutoDiff<T>(scalar - a.val, -a.der);\n}\n\ntemplate <typename T, typename S>\nAutoDiff<T> operator-(const AutoDiff<T>& a, S scalar) {\n    return AutoDiff<T>(a.val - scalar, a.der);\n}","type":"content","url":"/exercise-18-4#subtraction-1","position":35},{"hierarchy":{"lvl1":"Exercise 18.4","lvl4":"Division","lvl3":"Scalar operations","lvl2":"Implemented operators/functions (subtask 1, 2)"},"type":"lvl4","url":"/exercise-18-4#division-1","position":36},{"hierarchy":{"lvl1":"Exercise 18.4","lvl4":"Division","lvl3":"Scalar operations","lvl2":"Implemented operators/functions (subtask 1, 2)"},"content":"Mathematics:f(x) = \\frac{u(x)}{c} \\Rightarrow f'(x) = \\frac{u'(x)}{c}f(x) = \\frac{c}{u(x)} \\Rightarrow f'(x) = \\frac{-c \\cdot u'(x)}{u(x)^2}\n\nExample:f(x) = \\frac{x}{2} \\Rightarrow f'(x) = \\frac{1}{2}f(x) = \\frac{8}{x} \\Rightarrow f'(x) = -\\frac{8}{x^2}\n\nIn the code the implementation is:template <typename T, typename S>\nAutoDiff<T> operator/(const AutoDiff<T>& a, S scalar)\n{\n    return AutoDiff<T>(a.val / scalar, a.der / scalar);\n}\n\ntemplate <typename T, typename S>\nAutoDiff<T> operator/(S scalar, const AutoDiff<T>& a)\n{\n    T g  = a.val;\n    T g2 = g * g;\n    return AutoDiff<T>(scalar / g, -scalar * a.der / g2);\n}","type":"content","url":"/exercise-18-4#division-1","position":37},{"hierarchy":{"lvl1":"Exercise 18.4","lvl2":"Evaluate and plot Legendre-polynomials (and their derivatives) up to order 5, in the interval -1 \\le x \\le 1 (subtask 3)"},"type":"lvl2","url":"/exercise-18-4#evaluate-and-plot-legendre-polynomials-and-their-derivatives-up-to-order-5-in-the-interval-1-le-x-le-1-subtask-3","position":38},{"hierarchy":{"lvl1":"Exercise 18.4","lvl2":"Evaluate and plot Legendre-polynomials (and their derivatives) up to order 5, in the interval -1 \\le x \\le 1 (subtask 3)"},"content":"We implemented this process in main.cpp. It evaluates in the interval -1 \\le x \\le 1 the Legendre-polynomials up to order 5 and their derivatives (using AutoDiff). For the plot, it generates a legendre.csv file that can be plotted using plot_legendre.py program.","type":"content","url":"/exercise-18-4#evaluate-and-plot-legendre-polynomials-and-their-derivatives-up-to-order-5-in-the-interval-1-le-x-le-1-subtask-3","position":39},{"hierarchy":{"lvl1":"Exercise 18.4","lvl3":"Evaluation","lvl2":"Evaluate and plot Legendre-polynomials (and their derivatives) up to order 5, in the interval -1 \\le x \\le 1 (subtask 3)"},"type":"lvl3","url":"/exercise-18-4#evaluation","position":40},{"hierarchy":{"lvl1":"Exercise 18.4","lvl3":"Evaluation","lvl2":"Evaluate and plot Legendre-polynomials (and their derivatives) up to order 5, in the interval -1 \\le x \\le 1 (subtask 3)"},"content":"The Legendre polynomials are defined using the following recursive form:\\begin{aligned}\nP_{0} = 1 \\\\\nP_{1} = x \\\\\nP_{k}(x) = \\frac{(2k - 1)xP_{k-1}(x) - (k - 1)P_{k-2}(x)}{k}, \\qquad k \\ge 2\n\\end{aligned}\n\nThe program evaluates P, \\, P' for 400 (x) points in the interval [-1,1]. So it computes the values of the Legendre polynomials, and the values of their derivatives for each point.\nThen the program writes the results into the legendre.csv file in the following format:x, \\quad P_0, \\quad P_{0}', \\quad P_1, \\quad P_{1}', \\quad P_2, \\quad P_{2}', \\quad P_3, \\quad P_{3}', \\quad P_4, \\quad P_{4}', \\quad P_5, \\quad P_{5}'\n\nFor example a line looks like this:0.5, \\quad 1.0, \\quad 0.0, \\quad 0.5, \\quad 1.0, \\quad -0.375, \\quad 3.0, \\quad 0.625, \\quad 7.5, \\quad -0.625, \\quad -15.0, \\quad -1.875, \\quad -18.75\n\n(So for instance: P'_{5}(0.5) = -18.75)\n\nIn the end it also prints in the command window, whether the legendre.csv was created succesfully.","type":"content","url":"/exercise-18-4#evaluation","position":41},{"hierarchy":{"lvl1":"Exercise 18.4","lvl3":"Plots","lvl2":"Evaluate and plot Legendre-polynomials (and their derivatives) up to order 5, in the interval -1 \\le x \\le 1 (subtask 3)"},"type":"lvl3","url":"/exercise-18-4#plots","position":42},{"hierarchy":{"lvl1":"Exercise 18.4","lvl3":"Plots","lvl2":"Evaluate and plot Legendre-polynomials (and their derivatives) up to order 5, in the interval -1 \\le x \\le 1 (subtask 3)"},"content":"After running the plotting plot_legendre.py program, we got the following plot:\n","type":"content","url":"/exercise-18-4#plots","position":43},{"hierarchy":{"lvl1":"Exercise 18.5 (Pendulum)"},"type":"lvl1","url":"/exercise-18-5","position":0},{"hierarchy":{"lvl1":"Exercise 18.5 (Pendulum)"},"content":"In this section, we demonstrate how to implement differential equations without explicitly providing the derivatives (see, for example, Exercise 17.5.1).\nTo achieve this, we introduce the AutoDiff class, which handles the differentiation automatically.\n\nFor the pendulum, the governing second-order ODE is:\\alpha^{\\prime \\prime} = -\\frac{g}{l} \\sin (\\alpha), \\qquad \\alpha(t_0) = \\pi +0.001, \\; \\alpha^\\prime(t_0) = 0,\n\nOur results are consistent with previous conclusions\n\nExplicit Euler accumulates numerical errors and introduces artificial energy into the system.\nThis leads to an overestimation of the amplitude.\n\nCrank‚ÄìNicolson behaves as expected: the oscillations remain stable and physically correct, even with only a tiny perturbation in the initial angle.","type":"content","url":"/exercise-18-5","position":1},{"hierarchy":{"lvl1":"Exercise 18.5 (Pendulum)","lvl2":"State Space"},"type":"lvl2","url":"/exercise-18-5#state-space","position":2},{"hierarchy":{"lvl1":"Exercise 18.5 (Pendulum)","lvl2":"State Space"},"content":"","type":"content","url":"/exercise-18-5#state-space","position":3},{"hierarchy":{"lvl1":"Exercise 18.5 (Pendulum)","lvl2":"Pendulum solution"},"type":"lvl2","url":"/exercise-18-5#pendulum-solution","position":4},{"hierarchy":{"lvl1":"Exercise 18.5 (Pendulum)","lvl2":"Pendulum solution"},"content":"\n","type":"content","url":"/exercise-18-5#pendulum-solution","position":5},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/exercise-19-4","position":0},{"hierarchy":{"lvl1":""},"content":"Problem DescriptionThis exercise aims to compare different Runge-Kutta (RK) methods in terms of numerical accuracy and convergence when solving a first-order ordinary differential equation (ODE).The ODE considered is:\\begin{aligned}\n    y‚Ä≤(t)=‚àíy(t), \\\\\n    y(0)=1  \n\\end{aligned}\n\nIts analytical solution is:y(t)=e^{‚àít}\n\nThe numerical methods to be compared are:\n\nExplicit RK2 (Midpoint)\n\nExplicit RK4\n\nImplicit Gauss-Legendre 2-stage (s=2)\n\nImplicit Radau IIA 2-stage (s=2)\n\nWe compute the approximate values and errors at each time step\n\nPrinciples of the Four MethodsRK2 (Midpoint)\n\nType: Explicit second-order Runge-Kutta\n\nStep formula:\\begin{aligned}\n    k_1‚Äã=f(t_n‚Äã,y_n‚Äã), \\\\\n    k_2‚Äã=f(t_n‚Äã +h/2,y_n‚Äã+h k_1‚Äã/2), \\\\ \n    y_{n+1}‚Äã=y_n+h k_2‚Äã  \n\\end{aligned}\n\nCharacteristics: second-order convergence, explicit computation.RK4\n\nType: Explicit fourth-order Runge-Kutta\n\nStep formula:\\begin{aligned}\n    k_1‚Äã=f(t_n‚Äã,y_n‚Äã), \\\\\n    k_2‚Äã=f(t_n‚Äã+h/2,y_n‚Äã+h k_1‚Äã/2), \\\\\n    k_3‚Äã=f(t_n‚Äã+h/2,y_n‚Äã+h k_2‚Äã/2), \\\\\n    k_4‚Äã=f(t_n‚Äã + h,y_n‚Äã+h k_3‚Äã), \\\\\n    y_{n+1}‚Äã=y_n‚Äã+6/h‚Äã(k_1‚Äã+2 k_2‚Äã+2 k_3‚Äã+k_4)  \n\\end{aligned}\n\nCaracteristics: fourth-order convergence, explicit, higher accuracy than RK2.Gauss-Legendre 2-stage\n\nType: Implicit two-stage Gauss-Legendre Runge-Kutta\n\nUses two nodes (s=2) in a high-order implicit integration formula\n\nEach step requires solving a nonlinear system (fixed-point iteration or Newton iteration)\n\nCharacteristics: A-stable, second-order accuracy, implicit computation.\n\nRadau IIA 2-stage\n\nType: Implicit Radau IIA Runge-Kutta\n\nTwo nodes, implicit method\n\nSuitable for stiff ODEs, A-stable and second-order accurate\n\nStep requires solving a nonlinear system.\n\nError Comparison and ResultsCalculation conditions:\n\nFinal time ùëá = 1.0\n\nNumber of steps ùëÅ = 10 (step size ‚Ñé=0.1)\n\nSample numerical results:\n\nt\n\nRK2\n\nerror\n\nRK4\n\nerror\n\nGL2\n\nerror\n\nRadau2\n\nerror\n\n0.0\n\n1.00000000\n\n0.00000000\n\n1.00000000\n\n0.00000000\n\n1.00000000\n\n0.00000000\n\n1.00000000\n\n0.00000000\n\n0.1\n\n0.90500000\n\n0.00016258\n\n0.90483750\n\n0.00000008\n\n0.90483743\n\n0.00000001\n\n0.90483619\n\n0.00000122\n\n0.2\n\n0.81902500\n\n0.00029425\n\n0.81873090\n\n0.00000015\n\n0.81873078\n\n0.00000002\n\n0.81872854\n\n0.00000222\n\n0.3\n\n0.74121762\n\n0.00039940\n\n0.74081842\n\n0.00000020\n\n0.74081825\n\n0.00000003\n\n0.74081521\n\n0.00000301\n\n0.4\n\n0.67080195\n\n0.00048190\n\n0.67032029\n\n0.00000024\n\n0.67032008\n\n0.00000004\n\n0.67031642\n\n0.00000363\n\n0.5\n\n0.60707577\n\n0.00054511\n\n0.60653093\n\n0.00000027\n\n0.60653070\n\n0.00000004\n\n0.60652656\n\n0.00000410\n\n0.6\n\n0.54940357\n\n0.00059193\n\n0.54881193\n\n0.00000030\n\n0.54881168\n\n0.00000005\n\n0.54880718\n\n0.00000446\n\n0.7\n\n0.49721023\n\n0.00062492\n\n0.49658562\n\n0.00000031\n\n0.49658535\n\n0.00000005\n\n0.49658060\n\n0.00000470\n\n0.8\n\n0.44997526\n\n0.00064629\n\n0.44932929\n\n0.00000033\n\n0.44932901\n\n0.00000005\n\n0.44932410\n\n0.00000486\n\n0.9\n\n0.40722761\n\n0.00065795\n\n0.40656999\n\n0.00000033\n\n0.40656971\n\n0.00000005\n\n0.40656471\n\n0.00000495\n\n1.0\n\n0.36854098\n\n0.00066154\n\n0.36787977\n\n0.00000033\n\n0.36787949\n\n0.00000005\n\n0.36787446\n\n0.00000498\n\nObservations:\n\nRK2 exhibits larger errors, deviating noticeably from the exact solution.\n\nRK4 has very small errors, demonstrating clear advantage of fourth-order convergence.\n\nGauss-Legendre 2-stage and Radau IIA 2-stage have very small errors, comparable to RK4, and are A-stable implicit methods.\n\nReducing step size decreases the errors of RK4, GL2, and Radau2 rapidly, while RK2 decreases more slowly.\n\nConclusiona. Explicit methods:\n\nRK2 has limited accuracy, suitable for non-stiff ODEs with low precision requirements.\n\nRK4 is fourth-order accurate, computationally efficient, and suitable for general non-stiff problems.\n\nb. Implicit methods:\n\nGauss-Legendre and Radau IIA are more stable for stiff problems (A-stable).\n\nAccuracy is comparable to RK4, and larger step sizes can be used without divergence.\n\nc. Summary:\n\nFor non-stiff ODEs with high accuracy requirements, RK4 is the simplest and most effective choice.\n\nFor stiff ODEs or when larger step sizes are desired, implicit methods (Gauss-Legendre / Radau IIA) are more appropriate.","type":"content","url":"/exercise-19-4","position":1},{"hierarchy":{"lvl1":"Welcome to ASC-ODE‚Äôs documentation!"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"Welcome to ASC-ODE‚Äôs documentation!"},"content":"ASC-ODE is is a C++ library for solving ordinary differential equations (ODEs).\nThe equation is defined by the right hand side function.\nASC-ODE provides various time-steppers which may be used for odes with right hand sides\ngiven by a function object.\n\nA small demo for solving a mass-spring model as first order ODEy_0^\\prime & = & y_1 \\\\\ny_1^\\prime & = & -\\frac{k}{m} y_0\n\nis here:double tend = 4*M_PI;\nint steps = 100;\ndouble tau = tend/steps;\n\nVector<> y = { 1, 0 };  // initial conditions\nshared_ptr<NonlinearFunction> rhs = std::make_shared<MassSpring>(mass, stiffness);\n  \nExplicitEuler stepper(rhs);\n\nstd::cout << 0.0 << \"  \" << y(0) << \" \" << y(1) << std::endl;\nfor (int i = 0; i < steps; i++)\n  {\n     stepper.DoStep(tau, y);\n     std::cout << (i+1) * tau << \"  \" << y(0) << \" \" << y(1) << std::endl;\n  }\n\nThe result of this simulation in phase space is shown here:","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"Welcome to ASC-ODE‚Äôs documentation!","lvl2":"Installation"},"type":"lvl2","url":"/#installation","position":2},{"hierarchy":{"lvl1":"Welcome to ASC-ODE‚Äôs documentation!","lvl2":"Installation"},"content":"install XXX-odesolver it via git-clone:git clone https://github.com/my-github-clone/my-ode-solver.git\n\nTo configure and build some tests docd my-ode-solver\nmkdir build\ncd build\ncmake ..\nmake","type":"content","url":"/#installation","position":3},{"hierarchy":{"lvl1":"Welcome to ASC-ODE‚Äôs documentation!","lvl2":"Available time-stepping methods are"},"type":"lvl2","url":"/#available-time-stepping-methods-are","position":4},{"hierarchy":{"lvl1":"Welcome to ASC-ODE‚Äôs documentation!","lvl2":"Available time-stepping methods are"},"content":"...","type":"content","url":"/#available-time-stepping-methods-are","position":5}]}